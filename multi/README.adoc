= Multiple images
:toc:

In some cases, application includes multiple images and those need to be deployed to OpenShift. 

This directory include source of sample application that uses Redis-database.

== Redis

Redis-database is deployed as Docker-image.

* `oc new-app --docker-image=bitnami/redis:6.0.4 -l app=myapp --name myapp-redis -e REDIS_PASSWORD=passw0rd`
** https://hub.docker.com/r/bitnami/redis/[Bitnami Redis] is used.
* Deployment created service: _myapp-redis:6379_.
* Redis client: 
*** `oc exec -it  myapp-redis-1-q45mk redis-cli`
*** Authenticate: `auth passw0rd`
*** See https://redis.io/commands[Redis commands].

== Node.js application

Deploy application from GitHub.

* `oc new-app https://github.com/samisalkosuo/nodejs-sample -l app=myapp --name myapp-app -e REDIS_HOST=myapp-redis -e REDIS_PORT=6379 -e REDIS_PASSWORD=passw0rd --context-dir=multi`
** `--context-dir=multi` sets context dir within repository where source and Dockerfile is found.
** -e options set environment variables for Redis connection.
** REDIS_HOST is the service name that was created when Redis-database was deployed.

== Resources

By default, `oc new-app` does not include any resource limits or requests to deployed pods. It is a good practice to always set both resource request and limit. Resource meaning both CPU and RAM.

Patch deployment config to include resource request and limit:

* Create patch file for resources:
```
cat > resource-patch.yaml << EOF
spec:
  template:
    spec:
      containers:
      - name: myapp-app
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "500m"
EOF
```
* This patch file is for deployment config. After patching dc, pods will request 64Mi of memory and 100m of CPU.
* Patch using patch command:
** `oc patch dc myapp-app --patch "$(cat resource-patch.yaml)"`


== Persistence

Redis database does not have any persistence, and that's not good.

Prereq is that OpenShift has a storageclass configured. Storageclass dynamically provisions volumes when Persistent Volume Claim is created.

* Remember to be in the correct project.
* Create Persistent Volume Claim YAML:
```
cat > redis-pvc.yaml << EOF
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myapp-redis
  labels:
    app: myapp
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: managed-nfs-storage
EOF
```
* BTW, storage class used is https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client[NFS-Client Provisioser].
* Create the PVC:
** `oc create -f redis-pvc.yaml`
* Bitnami Redis container stores data to _/bitnami/redis/data_ directory.
* When Redis was deployed, deployment config was created. This DC is updated to use PVC.
** `oc get dc myapp-redis -o yaml`
* Patch file to add volume claim (resources requests and limits also added, because it is good or even best practice to do so):
```
cat > redis-patch.yaml << EOF
spec:
  template:
    spec:
      containers:
      - name: myapp-redis
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "500m"
        volumeMounts:
        - mountPath: "/bitnami/redis/data"
          name: redisclaim
      volumes:
        - name: redisclaim
          persistentVolumeClaim:
            claimName: myapp-redis
EOF
```
* Patch it:
** `oc patch dc myapp-redis --patch "$(cat redis-patch.yaml)"`

== ConfigMap and Secret

Both Redis and sample application were created using environment variables in the `oc new-app` command.
But let's create a ConfigMap for Redis host and port and a Secret for Redis password and then change deployments to use them.

* Create ConfigMap with Redis host and port:
** `oc create configmap redis-config --from-literal=REDIS_HOST=myapp-redis --from-literal=REDIS_PORT=6379` 
** Values specified in the command line, https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/[but there are other ways].
* Label ConfigMap:
** `oc label cm redis-config app=myapp`
* Create Secret with Redis password:
** `oc create secret generic redis-config --from-literal=REDIS_PASSWORD=passw0rd`
** Secret values specified in the command line, https://kubernetes.io/docs/concepts/configuration/secret/[but there are other ways].
* Label Secret:
** `oc label secret redis-config app=myapp`
* Create patch yaml to patch Redis Deployment Config to use Secret:
```
cat > redis-patch-secret.yaml << EOF
spec:
  template:
    spec:
      containers:
      - name: myapp-redis
        env:
        - name: REDIS_PASSWORD
          value: ""
          valueFrom:
            secretKeyRef:
              name: redis-config
              key: REDIS_PASSWORD
EOF
```
* Patch it:
** `oc patch dc myapp-redis --patch "$(cat redis-patch.yaml)"`
* Create patch yaml to patch sample app Deployment Config to use ConfigMap and Secret:
```
cat > app-patch-cm-and-secret.yaml << EOF
spec:
  template:
    spec:
      containers:
      - name: myapp-app
        env:
        - name: REDIS_HOST
          value: ""
          valueFrom:
            configMapKeyRef:
              name: redis-config
              key: REDIS_HOST
        - name: REDIS_PORT
          value: ""
          valueFrom:
            configMapKeyRef:
              name: redis-config
              key: REDIS_PORT
        - name: REDIS_PASSWORD
          value: ""
          valueFrom:
            secretKeyRef:
              name: redis-config
              key: REDIS_PASSWORD
EOF
```
* Patch it:
** `oc patch dc myapp-app --patch "$(cat app-patch-cm-and-secret.yaml)"`

== Readiness and liveness probes

Readiness and liveness probes should be present when deploying application to Kubernetes/OpenShift. Probes will inform the platform whether or not pod is ready or alive.

OpenShift makes it easy to add probes (probes can be added to YAML too):

* Node.js sample already includes _/health_ endpoint that is used.
* Set readiness probe:
** `oc set probe dc/myapp-app --readiness --get-url=http://:8080/health --period-seconds=20`
* Similar command for liveness probe:
** `oc set probe dc/myapp-app --liveness --get-url=http://:8080/health --initial-delay-seconds=30  --success-threshold=1 --failure-threshold=3`
* Redis container does not include HTTP endpoint to check liveness, but we can use TCP:
** `oc set probe dc/myapp-redis --liveness --open-tcp=6379 --period-seconds=20 --timeout-seconds=1`

